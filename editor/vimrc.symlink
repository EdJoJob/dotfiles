"
" File: .vimrc
" Author: Edward Evans
"
" Preamble -----------------------{{{
set nocompatible    " It's VIM, not VI
set shell=/usr/local/bin/zsh
" Install vim-plug if we don't arlready have it
if empty(glob("~/.vim/autoload/plug.vim"))
    " Ensure all needed directories exist  (Thanks @kapadiamush)
    execute '!mkdir -p ~/.vim/plugged'
    execute '!mkdir -p ~/.vim/autoload'
    " Download the actual plugin manager
    execute '!curl -fLo ~/.vim/autoload/plug.vim https://raw.github.com/junegunn/vim-plug/master/plug.vim'
endif
call plug#begin('~/dots/editor/vim.symlink/bundle/')
" Plugin listing {{{
" colorscheme
Plug 'w0ng/vim-hybrid'
" file browser
Plug 'tpope/vim-vinegar'
" get the output of shell commands in a new split buffer
Plug 'sjl/clam.vim'
" browse the undotree easily
Plug 'mbbill/undotree'
" the pretty at the bottom of the buffer
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
" change surrounding things
Plug 'tpope/vim-surround'
" mappings
Plug 'tpope/vim-unimpaired'
" repeat macros with .
Plug 'tpope/vim-repeat'
" syntax checking
if has('nvim')
    Plug 'benekastah/neomake'
    let s:neomake = 1
else
    Plug 'scrooloose/syntastic'
    let s:syntastic = 1
endif
" and completion
"Plug 'Valloric/YouCompleteMe'
" comment toggle
Plug 'scrooloose/nerdcommenter'
"lets work with latex
Plug 'LaTeX-Box-Team/LaTeX-Box'
Plug 'http://git.code.sf.net/p/vim-latex/vim-latex'
" use ag in vim like :grep
Plug 'rking/ag.vim'
" Get lots of language settings
Plug 'EdJoJob/llvmir-vim'
Plug 'octol/vim-cpp-enhanced-highlight'
Plug 'vim-jp/cpp-vim'
Plug 'davidhalter/jedi-vim'
Plug 'gorodinskiy/vim-coloresque'
Plug 'chrisbra/csv.vim'
Plug 'NLKNguyen/c-syntax.vim'
Plug 'tpope/vim-git'
Plug 'othree/html5.vim'
Plug 'leshill/vim-json'
Plug 'tpope/vim-markdown'
Plug 'hdima/python-syntax'
" restructured text
Plug 'Rykka/riv.vim'
" easily align things
Plug 'godlygeek/tabular'
" navigate tmux splits
Plug 'christoomey/vim-tmux-navigator'
Plug 'kien/ctrlp.vim'
Plug 'nathanaelkane/vim-indent-guides'
Plug 'bkad/CamelCaseMotion'
Plug 'freitass/todo.txt-vim'
" Work with VimL
Plug 'ynkdir/vim-vimlparser'
Plug 'dbakker/vim-lint'
" For presentations
Plug 'NLKNguyen/papercolor-theme'
"}}}
" Slow Plugs {{{
 " Git integration
 Plug 'tpope/vim-fugitive'
 " Mecurial Integration
 Plug 'ludovicchabant/vim-lawrencium'
 " indicate changed lines from repo in gutter
 Plug 'mhinz/vim-signify'
"}}}
" Testing Plugs {{{
Plug 'gastonsimone/vim-dokumentary'
Plug 'mattn/emmet-vim'
Plug 'SirVer/ultisnips'
" }}}
call plug#end()

"}}}
" Basic Config Settings ----------{{{
set title                       " set the title of the terminal window
set laststatus=2                " always show the statusline
set t_Co=256
if !has('nvim')
    set encoding=utf-8
    scriptencoding utf-8
endif
set splitbelow                  " new splits at bottom
set splitright                  " new splits at right
set mouse=a
set fillchars+=vert:█
set backspace=2                 " backspace over everything
set selectmode=                 " don't use select mode
set cmdheight=2                 " show lots of space for the commandline
set showcmd                     " show incomplete commands
set history=1000                " lots of command history
set lazyredraw                  " don't redraw the screen when executing macros
set matchtime=3                 " faster bracket matching
set timeoutlen=500
set ttimeoutlen=0               " give me time to complete mappings
set foldmethod=syntax
set foldlevelstart=99
if exists('+relativenumber')
    set relativenumber              " show line numbers
endif
set number
set numberwidth=1
set cursorline                  " highlight the current line
set wildmode=longest:full       " make cmdline tab completion similar to bash
set wildmenu                    " enable ctrl-n and ctrl-p to scroll thru matches
set wildignore+=*.o,*.obj,*~    " stuff to ignore when tab completing
set wildignore+=.\s+
set scrolloff=5					" keep this number of lines on the screen when scrolling vertically
set colorcolumn=80,100
let maplocalleader='|'
set suffixes+=.pyc,.pyo
set suffixes+=.class
" printing {{{
set printencoding=utf-8
set printfont=Liberation\ Mono\ for\ Powerline
"}}}
"Not used as I have airline
"set ruler                                              " display cursor position
set rulerformat=%55(%{strftime('%a\ %b\ %e\ %I:%M\ %p')}\ %5l,%-6(%c%V%)\ %P%)
"}}}
" Formatting options -------------{{{
set nolist                                              " show spacer characters
set listchars=tab:▸\ ,eol:¬,extends:❯,precedes:❮,trail:· " set the spacing characters
set linebreak                                           " wrap lines at &breakat when nolist
" leader for linebreak lines
set showbreak=↳
set breakindent
set breakindentopt=shift:2
set smarttab
set expandtab
set softtabstop=4
set shiftwidth=4
set tabstop=4
set wrap
set formatoptions+=q                                    " format comments
set formatoptions+=r                                    " insert comment header after enter in insert
set formatoptions+=n                                    " recognize numbered lists
set formatoptions+=1                                    " Don't break a line on a 1 letter word, rather break before it
set formatoptions+=l                                    " long lines in insert mode are not broken
set formatoptions+=j                                    " when joining comment lines, remove comment leader
"}}}
" Spelling Settings --------------{{{
set dictionary=/usr/dict/words
set spelllang=en_au
set nospell
"}}}
" Quick Editing ------------------{{{

nnoremap <leader>ev :tabedit ~/dots/editor/vimrc.symlink<cr>
nnoremap <leader>sv :source ~/dots/editor/vimrc.symlink<cr>
nnoremap <leader>et :tabedit ~/dots/todo.symlink/todo/todo.txt<cr>
nnoremap <leader>ez :tabedit ~/dots/zsh/zshrc.symlink<cr>

"}}}
" Backup Settings ----------------{{{
set backup                                            " enable backups
if has('persistent_undo')
    set undodir=~/.vim/tmp/undo//                         " undo files
    if !isdirectory(expand(&undodir))
        call mkdir(expand(&undodir), "p")
    endif
    set undofile
endif
set backupdir=~/.vim/tmp/backup//                     " backups
set directory=~/.vim/tmp/swap//                       " swap files
"let g:yankring_history_dir='~/.vim/tmp/yankring'

" Make those folders automatically if they don't already exist.
if !isdirectory(expand(&backupdir))
    call mkdir(expand(&backupdir), 'p')
endif
if !isdirectory(expand(&directory))
    call mkdir(expand(&directory), 'p')
endif
"}}}
" Search Settings ----------------{{{

nnoremap / /\v
vnoremap / /\v
set ignorecase
set smartcase
set gdefault
set incsearch
set showmatch
set hlsearch
nnoremap <silent> <leader><space> :noh<cr>:call clearmatches()<cr>

" Open a Quickfix window for the last search.
nnoremap <silent> <leader>/ :execute 'vimgrep /'.@/.'/gj %'<CR>:copen<CR>

" Ag for the last search.
nnoremap <silent> <leader>? :execute "Ag! '" . substitute(substitute(substitute(@/, "\\\\<", "\\\\b", ""), "\\\\>", "\\\\b", ""), "\\\\v", "", "") . "'"<CR>

"}}}
" Filetype Specific --------------{{{
" Vim {{{
augroup PERSONAL_VIM
    au!
    au FileType vim setlocal foldmethod=marker
    au FileType vim setlocal iskeyword+=:
augroup END
" }}}
" tex {{{
augroup TEX
    au!
    au FileType tex set tw=79
augroup END
" }}}
" rst {{{
augroup reStructured
    au!
    au Filetype rst set softtabstop=3
    au Filetype rst set shiftwidth=3
    au Filetype rst set tabstop=3
    if has('nvim')
        au Filetype rst command! -buffer Preview call jobstart(['restview', '--css=/Users/eevans43/src/rhythm.css/dist/css/rhythm.css', '--css=/Users/eevans43/src/rhythm.css/syntax/molokai.css', expand('%:p')])
    endif
augroup END
" }}}
" Git {{{
"Spellcheck when writing git logs
augroup PERSONAL_GIT
    au!
    autocmd FileType gitcommit setlocal spell
augroup END
" }}}
" Python {{{
let g:python_version_2 = 1
let g:python_highlight_all = 1
augroup PERSONAL_PYTHON
    au!
    au Filetype python set textwidth=79  " lines longer than 79 columns will be broken
    au Filetype python set shiftwidth=4  " operation >> indents 4 columns; << unindents 4 columns
    au Filetype python set tabstop=4     " a hard TAB displays as 4 columns
    au Filetype python set expandtab     " insert spaces when hitting TABs
    au Filetype python set softtabstop=4 " insert/delete 4 spaces when hitting a TAB/BACKSPACE
    au Filetype python set shiftround    " round indent to multiple of 'shiftwidth'
    au Filetype python set autoindent    " align the new line indent with the previous line
    "au FileType python set foldmethod=indent
augroup END
" }}}
" Java {{{
augroup PERSONAL_JAVA
    au!
    au FileType java setlocal shiftwidth=4
    au FileType java setlocal cinoptions+=j1
    au FileType java let java_highlight_all=1
    au FileType java let java_comment_strings=1
    au FileType java let java_highlight_java_lang_ids=1
    au FileType java let java_highlight_functions="style"
    au BufEnter,BufRead *.java syntax sync fromstart
augroup END
" }}}
" crontab {{{
augroup crontab
    au!
    au FileType crontab setlocal nobackup nowritebackup
augroup END
" }}}
"}}}
" Folding ------------------------{{{
" "Focus" the current line.{{{
"  Basically
"
" 1. Close all folds.
" 2. Open just the folds containing the current line.
" 3. Move the line to a little bit (15 lines) above the center of the screen.
" 4. Pulse the cursor line.  My eyes are bad.
"
" This mapping wipes out the z mark, which I never use.
"
" I use :sus for the rare times I want to actually background Vim.
" }}}
nnoremap <c-z> mzzMzvzz15<c-e>`z
nnoremap <space> za
set foldtext=FoldText()
" fold function FoldText {{{
function! FoldText()
    let l:lpadding = &fdc
    redir => l:signs
    execute 'silent sign place buffer='.bufnr('%')
    redir End
    let l:lpadding += l:signs =~? 'id=' ? 2 : 0

    if exists('+relativenumber')
        if (&number)
            let l:lpadding += max([&numberwidth, strlen(line('$'))]) + 1
        elseif (&relativenumber)
            " change to 3 as rare to have more than 99 lines on the screen
            let l:lpadding += max([&numberwidth, 3])
        endif
    else
        if (&number)
            let l:lpadding += max([&numberwidth, strlen(line('$'))]) + 1
        endif
    endif

    " expand tabs
    let l:start = substitute(getline(v:foldstart), '\t', repeat(' ', &tabstop), 'g')
    let l:end = substitute(substitute(getline(v:foldend), '\t', repeat(' ', &tabstop), 'g'), '^\s*', '', 'g')

    let l:info = ' (' . (v:foldend - v:foldstart) . ')'
    let l:infolen = strlen(substitute(l:info, '.', 'x', 'g'))
    let l:width = winwidth(0) - l:lpadding - l:infolen

    let l:separator = ' … '
    let l:separatorlen = strlen(substitute(l:separator, '.', 'x', 'g'))
    let l:start = strpart(l:start , 0, l:width - strlen(substitute(l:end, '.', 'x', 'g')) - l:separatorlen)
    let l:text = l:start . ' … ' . l:end

    return l:text . repeat(' ', l:width - strlen(substitute(l:text, '.', 'x', 'g'))) . l:info
endfunction " }}}
"}}}
" Functions ----------------------{{{
" Only show cursorline in the current window and in normal mode.{{{
augroup cline
    au!
    au WinLeave,InsertEnter * set nocursorline
    au WinEnter,InsertLeave * set cursorline
augroup END
"}}}
" Make sure Vim returns to the same line when you reopen a file. {{{
augroup line_return
    au!
    au BufReadPost *
                \ if line("'\"") > 0 && line("'\"") <= line("$") |
                \ execute 'normal! g`"zvzz' |
                \ endif
augroup END
"}}}
" Highlight end of line whitespace{{{
highlight EOLWS ctermbg=red guibg=red
augroup PERSONAL_WHITESPACE
    au!
    autocmd InsertEnter * syn clear EOLWS | syn match EOLWS excludenl /\s\+\%#\@!$/
    autocmd InsertLeave * syn clear EOLWS | syn match EOLWS excludenl /\s\+$/
augroup END
"}}}
" TODO etc Tags {{{
" Highlight all tags
if has('autocmd')
    " Highlight TODO, FIXME, NOTE, etc.
    if v:version > 701
        augroup PERSONAL_TODO_HIGHLIGHT
            au!
            autocmd Syntax * call matchadd('Todo',  '\W\zs\(TODO\|FIXME\|CHANGED\|XXX\|BUG\|HACK\):')
            autocmd Syntax * call matchadd('Debug', '\W\zs\(NOTE\|INFO\|IDEA\):')
        augroup END
    endif
endif

"}}}
" Resize splits when the window is resized {{{
augroup PERSONAL_RESIZE
    au!
    au VimResized * :wincmd =
augroup END
"}}}
"}}}
" Mappings -----------------------{{{

" Moving blocks{{{
vnoremap < <gv
vnoremap > >gv
"}}}

" make Y work more like D and C
nnoremap Y y$

" move up and down screen lines rather than file lines{{{
nnoremap j gj
nnoremap k gk
noremap gj j
noremap gk k
"}}}

" switch tick and inv comma as going back to actual position is far more useful
noremap ` '
noremap ' `

" Source selection / line of vimscript
vnoremap <leader>S y:execute @@<cr>:echo 'Sourced selection.'<cr>
nnoremap <leader>S ^vg_y:execute @@<cr>:echo 'Sourced line.'<cr>

" Get all TODO tags in files above current directory
noremap <Leader>to :Ag! "\b(TODO\|FIXME\|CHANGED\|XXX\|BUG\|HACK\|NOTE\|INFO\|IDEA)\b" <CR>
noremap <Leader>ti :Ag! "\b(TODO\|FIXME\|CHANGED\|XXX\|BUG\|HACK\|NOTE\|INFO\|IDEA)\b" % <CR>

" Select (charwise) the contents of the current line, excluding indentation.
" Great for pasting Python lines into REPLs.
nnoremap vv ^vg_

" Sudo to write
cabbr w!! w !sudo tee % >/dev/null

" Don't move on * {{{
" I'd use a function for this but Vim clobbers the last search when you're in
" a function so fuck it, practicality beats purity.
nnoremap <silent> * :let stay_star_view = winsaveview()<cr>*<c-o>:call winrestview(stay_star_view)<cr>
"}}}

" Keep search matches in the middle of the window.
nnoremap n nzzzv
nnoremap N Nzzzv

" Same when jumping around
nnoremap g; g;zz
nnoremap g, g,zz
nnoremap <c-o> <c-o>zz

" Easier to type, and I never use the default behaviour.
noremap H ^
noremap L $
vnoremap L g_

" List navigation {{{
nnoremap <left>  :cprev<cr>zvzz
nnoremap <right> :cnext<cr>zvzz
nnoremap <up>    :lprev<cr>zvzz
nnoremap <down>  :lnext<cr>zvzz
"}}}

"}}}
" Plugins ------------------------{{{
" ack.vim {{{
let g:ackhighlight=1
" }}}
" CtrlP {{{
let g:ctrlp_custom_ignore='build'
" }}}
" netrw {{{
let g:netrw_liststyle=0 " get tree-style listing
" }}}
" riv.vim {{{
let g:riv_highlight_code='lua,python,cpp,javascript,vim,sh,java'
" }}}
" LatexBox {{{"
let g:LatexBox_build_dir='build'
"}}}
" UndoTree {{{
nnoremap <F2> :UndotreeToggle<CR>
"}}}
" LaTeX Suite {{{"
let g:tex_flavor='latex'
set grepprg=grep\ -nH\ $*
nmap <C-space> <Plug>IMAP_JumpForward
imap <S-Space> <Plug>IMAP_JumpBack
nmap <S-Space> <Plug>IMAP_JumpBack
"let g:Tex_CompileRule_pdf="pdflatex -output-directory build -interaction=nonstopmode -file-line-error-style $*"
" Use the update script in the directory
let g:Tex_CompileRule_pdf='%:p:h/update.sh'
let g:Tex_DefaultTargetFormat='pdf'
"}}}
" Signify {{{"
let g:signify_vcs_list = [ 'git', 'hg' ]
"}}}
" Syntastic {{{"
if exists('s:syntastic')
    " Shorter Error Line
    let g:syntastic_stl_format = '[%E{Er:%fe #%e}%B{, }%W{Wa:%fw #%w}]'
    let g:syntastic_cpp_no_default_include_dirs = 1
    let g:syntastic_cpp_remove_include_errors = 1
    let g:syntastic_cpp_compiler = 'g++'
    let g:syntastic_aggregate_errors = 1
    " Syntax Checkers
    let g:syntastic_python_checkers =  ['python', 'pylint']
    let g:syntastic_vim_checkers = ['vint', 'vim-lint']
endif
"}}}
" Neomake {{{
augroup personal_neomake
    au!
    au BufWritePost,BufEnter * if exists('s:neomake') | Neomake | endif
    "This doesn't work, although I would like it to (should give lint as I type)
    "au TextChanged * if exists('s:neomake') | update | Neomake endif
augroup END
" }}}
" jedi {{{
let g:jedi#use_tabs_not_buffers = 0
let g:jedi#use_splits_not_buffers = 'right'
" }}}
" vim-indent-guides {{{
let g:indent_guides_auto_colors = 0
let g:indent_guides_guide_size = 1
let g:indent_guides_start_level = 2
let g:indent_guides_autocmds_enabled = 1
let g:indent_guides_enable_on_vim_startup = 1
augroup PERSONAL_INDENT_COLORS
    au!
    au VimEnter,Colorscheme * :hi IndentGuidesOdd  guibg=#3f2d3c ctermbg=236
    au VimEnter,Colorscheme * :hi IndentGuidesEven guibg=#2d363f ctermbg=240
augroup END
" }}}
" dokumentary {{{
let g:dokumentary_docprgs = {'python': ''}
" }}}
" utilsnips {{{
let g:UltiSnipsExpandTrigger = '<tab>'
let g:UltiSnipsJumpForwardTrigger = '<c-b>'
let g:UltiSnipsJumpBackwardTrigger = '<c-k>'

let g:UltiSnipsEditSplit = 'context'
" }}}
" CamelCaseMotion {{{
call camelcasemotion#CreateMotionMappings('<localleader>')
" }}}
"}}}
" MiniPlugins --------------------{{{
" Highlight Word {{{
"
" This mini-plugin provides a few mappings for highlighting words temporarily.
"
" Sometimes you're looking at a hairy piece of code and would like a certain
" word or two to stand out temporarily.  You can search for it, but that only
" gives you one color of highlighting.  Now you can use <leader>N where N is
" a number from 1-6 to highlight the current word in a specific color.

function! HiInterestingWord(n) " {{{
    " Save our location.
    normal! mz

    " Yank the current word into the z register.
    normal! "zyiw

    " Calculate an arbitrary match ID.  Hopefully nothing else is using it.
    let mid = 86750 + a:n

    " Clear existing matches, but don't worry if they don't exist.
    silent! call matchdelete(mid)

    " Construct a literal pattern that has to match at boundaries.
    let pat = '\V\<' . escape(@z, '\') . '\>'

    " Actually match the words.
    call matchadd('InterestingWord' . a:n, pat, 1, mid)

    " Move back to our original location.
    normal! `z
endfunction " }}}

" Mappings {{{

nnoremap <silent> <leader>1 :call HiInterestingWord(1)<cr>
nnoremap <silent> <leader>2 :call HiInterestingWord(2)<cr>
nnoremap <silent> <leader>3 :call HiInterestingWord(3)<cr>
nnoremap <silent> <leader>4 :call HiInterestingWord(4)<cr>
nnoremap <silent> <leader>5 :call HiInterestingWord(5)<cr>
nnoremap <silent> <leader>6 :call HiInterestingWord(6)<cr>

" }}}

" }}}
" Next and Last {{{
"
" Motion for "next/last object".  "Last" here means "previous", not "final".
" Unfortunately the "p" motion was already taken for paragraphs.
"
" Next acts on the next object of the given type, last acts on the previous
" object of the given type.  These don't necessarily have to be in the current
" line.
"
" Currently works for (, [, {, and their shortcuts b, r, B.
"
" Next kind of works for ' and " as long as there are no escaped versions of
" them in the string (TODO: fix that).  Last is currently broken for quotes
" (TODO: fix that).
"
" Some examples (C marks cursor positions, V means visually selected):
"
" din'  -> delete in next single quotes                foo = bar('spam')
"                                                      C
"                                                      foo = bar('')
"                                                                C
"
" canb  -> change around next parens                   foo = bar('spam')
"                                                      C
"                                                      foo = bar
"                                                               C
"
" vin"  -> select inside next double quotes            print "hello ", name
"                                                       C
"                                                      print "hello ", name
"                                                             VVVVVV

onoremap an :<c-u>call <SID>NextTextObject('a', '/')<cr>
xnoremap an :<c-u>call <SID>NextTextObject('a', '/')<cr>
onoremap in :<c-u>call <SID>NextTextObject('i', '/')<cr>
xnoremap in :<c-u>call <SID>NextTextObject('i', '/')<cr>

onoremap al :<c-u>call <SID>NextTextObject('a', '?')<cr>
xnoremap al :<c-u>call <SID>NextTextObject('a', '?')<cr>
onoremap il :<c-u>call <SID>NextTextObject('i', '?')<cr>
xnoremap il :<c-u>call <SID>NextTextObject('i', '?')<cr>


function! s:NextTextObject(motion, dir)
    let c = nr2char(getchar())
    let d = ''

    if c ==# 'b' || c ==# '(' || c ==# ')'
        let c = '('
    elseif c ==# 'B' || c ==# '{' || c ==# '}'
        let c = '{'
    elseif c ==# 'r' || c ==# '[' || c ==# ']'
        let c = '['
    elseif c ==# "'"
        let c = "'"
    elseif c ==# '"'
        let c = '"'
    else
        return
    endif

    " Find the next opening-whatever.
    execute 'normal! ' . a:dir . c . "\<cr>"

    if a:motion ==# 'a'
        " If we're doing an 'around' method, we just need to select around it
        " and we can bail out to Vim.
        execute 'normal! va' . c
    else
        " Otherwise we're looking at an 'inside' motion.  Unfortunately these
        " get tricky when you're dealing with an empty set of delimiters because
        " Vim does the wrong thing when you say vi(.

        let open = ''
        let close = ''

        if c ==# '('
            let open = '('
            let close = ')'
        elseif c ==# '{'
            let open = '{'
            let close = '}'
        elseif c ==# '['
            let open = "\\["
            let close = "\\]"
        elseif c ==# "'"
            let open = "'"
            let close = "'"
        elseif c ==# '"'
            let open = '"'
            let close = '"'
        endif

        " We'll start at the current delimiter.
        let start_pos = getpos('.')
        let start_l = start_pos[1]
        let start_c = start_pos[2]

        " Then we'll find it's matching end delimiter.
        if c ==# "'" || c ==# '"'
            " searchpairpos() doesn't work for quotes, because fuck me.
            let end_pos = searchpos(open)
        else
            let end_pos = searchpairpos(open, '', close)
        endif

        let end_l = end_pos[0]
        let end_c = end_pos[1]

        call setpos('.', start_pos)

        if start_l == end_l && start_c == (end_c - 1)
            " We're in an empty set of delimiters.  We'll append an "x"
            " character and select that so most Vim commands will do something
            " sane.  v is gonna be weird, and so is y.  Oh well.
            execute "normal! ax\<esc>\<left>"
            execute 'normal! vi' . c
        elseif start_l == end_l && start_c == (end_c - 2)
            " We're on a set of delimiters that contain a single, non-newline
            " character.  We can just select that and we're done.
            execute 'normal! vi' . c
        else
            " Otherwise these delimiters contain something.  But we're still not
            " sure Vim's gonna work, because if they contain nothing but
            " newlines Vim still does the wrong thing.  So we'll manually select
            " the guts ourselves.
            let whichwrap = &whichwrap
            set whichwrap+=h,l

            execute 'normal! va' . c . 'hol'

            let &whichwrap = whichwrap
        endif
    endif
endfunction

" }}}
" Jumping to tags. {{{
"
" Basically, <c-]> jumps to tags (like normal) and <c-\> opens the tag in a new
" split instead.
"
" Both of them will align the destination line to the upper middle part of the
" screen.  Both will pulse the cursor line so you can see where the hell you
" are.  <c-\> will also fold everything in the buffer and then unfold just
" enough for you to see the destination line.
function! JumpToTag()
    execute "normal! \<c-]>mzzvzz15\<c-e>"
    execute 'keepjumps normal! `z'
    Pulse
endfunction
function! JumpBackTag(count)
    execute a:count "normal!\<c-t>mzzvzz15\<c-e>"
    execute 'keepjumps normal! `z'
    Pulse
endfunction
function! JumpToTagInSplit()
    execute "normal! \<c-w>v\<c-]>mzzMzvzz15\<c-e>"
    execute 'keepjumps normal! `z'
    Pulse
endfunction
nnoremap <silent><c-]> :silent! call JumpToTag()<cr>
nnoremap <c-t> :call JumpBackTag(v:count1)<cr>
nnoremap <silent><c-\> :silent! call JumpToTagInSplit()<cr>
"}}}
" Pulse Line {{{
function! s:Pulse() " {{{
    redir => old_hi
    silent execute 'hi CursorLine'
    redir END
    let old_hi = split(old_hi, '\n')[0]
    let old_hi = substitute(old_hi, 'xxx', '', '')

    let steps = 4
    let width = 1
    let start = width
    let end = steps * width
    let color = 233

    for i in range(start, end, width)
        execute 'hi CursorLine ctermbg=' . (color + i)
        redraw
        sleep 6m
    endfor
    for i in range(end, start, -1 * width)
        execute 'hi CursorLine ctermbg=' . (color + i)
        redraw
        sleep 6m
    endfor

    execute 'hi ' . old_hi
endfunction " }}}
command! -nargs=0 Pulse call s:Pulse()
"}}}
"}}}
" GUI Settings -------------------{{{
set guifont=Liberation\ Mono\ for\ Powerline\ 8
" no right hand scrollbar
set guioptions-=r
set guioptions-=R
" no left hand scrollbar
set guioptions-=l
set guioptions-=L
" no toolbar
set guioptions-=T
" autoselect into @+
set guioptions+=P
set guioptions+=A
" console for simple choices rather than dialogue
set guioptions+=c
" have a menubar
set guioptions+=m
"}}}
" Airline ------------------------{{{
let g:airline_powerline_fonts=1
if !exists('g:airline_symbols')
    let g:airline_symbols = {}
endif

let g:airline#extensions#quickfix#quickfix_text = 'Quickfix'
let g:airline#extensions#quickfix#location_text = 'Location'
let g:airline#extensions#bufferline#enabled = 0
let g:airline#extensions#syntastic#enabled = 1
let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#eclim#enabled = 1
" shorter whitespace errors
let g:airline#extensions#whitespace#trailing_format = 'tr[%s]'
let g:airline#extensions#whitespace#mixed_indent_format = 'id[%s]'
" disable branch label
"let g:airline#extensions#branch#enabled = 0


function! AirlineInit()
endfunction
augroup PERSONAL_AIRLINE
    au!
    autocmd VimEnter * call AirlineInit()
augroup END
let g:airline_theme='hybrid'
"}}}
" Colours-------------------------{{{
set background=dark
colorscheme hybrid
highlight WhitespaceEOL ctermbg=DarkYellow guibg=DarkYellow
" Interesting Word Default Highlights {{{

hi def InterestingWord1 guifg=#000000 ctermfg=16 guibg=#ffa724 ctermbg=214
hi def InterestingWord2 guifg=#000000 ctermfg=16 guibg=#aeee00 ctermbg=154
hi def InterestingWord3 guifg=#000000 ctermfg=16 guibg=#8cffba ctermbg=121
hi def InterestingWord4 guifg=#000000 ctermfg=16 guibg=#b88853 ctermbg=137
hi def InterestingWord5 guifg=#000000 ctermfg=16 guibg=#ff9eb8 ctermbg=211
hi def InterestingWord6 guifg=#000000 ctermfg=16 guibg=#ff2c4b ctermbg=195

" }}}
"}}}
